The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses. Visit MIT OpenCourseWare at ocw.mit.edu. Alright, let's get started everyone.
So good afternoon. Welcome to the second lecture of 6.0001 and also of 600. So as always, if you'd like to follow along with the lecture, with the lectures, please go ahead and download the slides and the code that I'll provide at least an hour before class every day. So quick recap of what we did last time. So last time we talked a little bit about what a computer is.
And I think the main takeaway from the last lecture is really that a computer only does what it is told, right? So it's not going to spontaneously make decisions on its own. You as the programmer have to tell it what you want it to do by writing programs. Okay, so we talked about simple objects, and these objects were of different types. So we saw integers, floats, and Booleans.
And then we did a couple of simple operations with them. Today we're going to look at a different, a new type of object called a string. And then we're going to introduce some more powerful things in our programming toolbox. So we're going to look at how to branch within a program and how to make the computer repeat certain tasks within our program. All right.
So let's begin by looking at strings. So strings are a new object type. We've seen so far integers, which were whole numbers, floats, which were decimal numbers. And we've seen Booleans, which were true and false. So strings are going to be sequences of characters.
And these characters can be anything. They can be letters, digits, special characters, and also spaces. And you tell Python that you're talking about a string object by enclosing it in quotation marks. So in this case, I'm creating an object whose value is H-E-L-L-O space T-H-E-R-E. And Python knows it's a string object, because we're enclosing it in quotations.
They could be either double quotes or single quotes. But as long as you're consistent, it doesn't matter. And this object, we're binding it to this variable named high. And we're using that using the equal sign, which is the assignment operator. So from now on, whenever we refer to this variable high, Python's going to say, oh, I know what the value is, and it's that string of characters.
So we're going to learn about 2 things that you can do on strings today, 2 operations. 1 is to concatenate them. And concatenation is really just a fancy word for using this plus operator, which means put the strings together. So, I have this original variable named hi, and I create a new variable called name. And in it, I'm going to assign the string a and a to the variable name.
And when I use the plus operator in between hi and name, those 2 variables, Python is going to look at the values of those 2, and it's going to just put them together. I'm going to switch to Spider. And this is just that example from the slides. So let's see what happens. So I have the variable, hi, the variable name, and I'm just concatenating those 2 together, and then I'm going to print that out.
So if I run the code, notice it prints out, hello there, Anna. There's no space. And there's no space because the concatenation operator, the plus, doesn't add any spaces implicitly. So again, another example of just computer just doing what it's told. If we want to add a space we'd have to actually insert the space manually.
So that's this line here, line 8. And in this line we're concatenating the value of the variable high with a space. Notice we're putting it in quotation marks, just a space, and then with name. So if we go ahead and print that value, notice this was that garbage greeting there, and now we have a proper greeting. So that's the concatenation between strings.
And then the other thing we're going to look at related to strings is the star operator. So that's this 1 here on line 10. So Python allows you to use the star operator, which stands for multiplication, between a string and a number. And when you do that, Python interprets it as repeat that string that many number of times. So in this case, I'm creating a silly greeting.
And I'm concatenating the value of hi, which is hello there, with the space plus the name. So notice here I'm using parentheses to tell Python do this operation first, and then multiply whatever the result of this is by 3. So if I print that out, it's going to multiply the space with my name 3 times. And it's going to concatenate that with hello there. So that's exactly what it printed out there.
Last lecture, we talked a little bit about print. Today, I'm going to talk about some nuances related to print. So you use print to interact with the user. It's cool to write programs that print things out to the user. So the keyword here being print.
And then you put parentheses after print, and in the parentheses you put in whatever you want to show the user. So in this little program I have, I create a variable named x, I assign it the value 1, and then I print 1. Here, I'm casting. So I'm taking the number 1, the integer 1, and I'm casting it to a string. And you'll see why in a moment.
So I want to bring to your attention a couple things here. So in the first print, I'm using commas everywhere here. And in the second print, I'm using plus. So by definition, you can use commas inside the parentheses of print. And if you use a comma, Python's going to automatically add a space in between the 2 things that the comma is in between, the values.
So my fav num is the first thing. And the second thing is whatever is after the comma. Let's take x. So if you use a comma, Python's going to automatically insert a space for you. Sometimes you might want that.
Sometimes you might not. If you don't want that, you can use the concatenation operation, the plus, and you can add all of your little bits together to create 1 big string. If you're using commas, the items, the objects in between the commas do not all have to be strings. That's the plus side of using commas. But the downside is you get spaces everywhere.
If you use plus operator, the plus side is Python does exactly what you tell it to do, but everything has to be a string object. So myfave num is a string object. You have to convert all of your numbers to string objects, and so on. So if we look at spider, this is almost the same code. So here I don't have spaces anywhere.
So you can see that the first line here has commas everywhere. So I'm going to have spaces in between every 1 of the things that I'm printing out. This line here is sort of a combination between commas and concatenation. So depending on where I use the comma, I'm going to have an extra space. And this line here just has concatenation everywhere.
So if I run this, notice this very first line added spaces everywhere in between all my objects. The second 1 added spaces somewhere. And you can sort of trace through and see exactly where the spaces were added. And the last line here didn't add spaces anywhere. OK.
So printing things out to the console is nice, but the second part of sort of writing an interactive program is getting input from the user. And that's a more interesting part. So if you've done problem set 0, you might have sort of already tried to understand this on your own. But here we are. So the way you get input from the user is using this command function called input.
And inside the parentheses, you type in whatever you'd like to prompt the user with. So in this case, in my example here, I have input. And then here, I said, type anything. So the user is going to see this text here. And then the program is just going to stop.
And it's going to wait for the user to type in something and hit Enter. As soon as the user types in Enter, whatever the user types in becomes a string. If the user types in a number, for example, that becomes the string of that number. So everything the user types in is going to be made as a string. In this line right here, whatever the user types in becomes a string.
And we're going to bind that string object to this variable called text. So now further in my program, I could do whatever I want with this variable text. In this case, I'm going to print 5 star text. So if the user, for example, gave me ha, I'm going to print ha 5 times. If the user gave me 5, what do you think is going to be printed out?
25 or 5, 5 times? Great. Yes, exactly. 5, 5 times. Oftentimes, you don't want to work with numbers as strings.
You want to work with numbers as numbers. So you have to cast. And we learned that last lecture. You cast by just putting in this little bit right in front of the input. And you can cast it to whatever type you want.
Here I cast it to an int, but you can also cast to a float if you want to work with floats. And that converts whatever the user typed in, as long as it's some number that Python knows how to convert, into the number itself. So in this case, if the user gives me 5, I'm going to print out 5 times 5 instead of 5, 5 times. So that's the code here. So The first bit is I'm going to get the user to type in anything, and I'm going to put 555.
And then when I type in the number, since I'm casting it, I'm going to do operations with the number. Yeah, question? Why do you want to cast to? Oh, the question is why do you want to cast to a string? Why do you want to cast to?
Oh, the question is why do you want to cast to a string? Why do you want to cast a string to a number? Oh, so Python always, whatever you type in, just by default, by definition of the input command, Python always makes it a string. So if you want to work with numbers, you have to explicitly tell it I'm going to work with a number. So even if you give it the number 5, it's going to think it's the string 5.
Yeah. That's just how input works. The next thing we're going to look at is ways that you can start adding tests in your code. And before you can start adding tests in your code, you need to be able to do the actual tests. So this is where comparison operators come in.
So here, let's assume that I and j are variables. The Following comparisons are going to give you a Boolean. So it's either going to say this is true or this is false. So that's going to be your test. So if INJ are variables, you're allowed to compare ints with ints, floats with floats, strings with strings.
And you're allowed to compare ints and floats between themselves, but you're not allowed to compare a string with a number. In fact, if you even try to do that in Python, in Spyder here, if I try to say, is the letter a greater than 5, I get some angry text right here. And this just tells me Python doesn't understand the meaning of how do I compare a string with a number. So just like in math, we can do these usual comparisons. We can say if something is greater than something, greater equal to, less than, less than, or equal to.
I'd like to bring to your attention the equality. So the Single equal sign is an assignment. So you're taking a value and you're signing it to a variable. But when you're doing the double equal sign, this is the test for equality. Is the value of variable I the same as the value of the variable j?
And that's, again, also going to give you a Boolean, either true or false. And you can also test for inequality with the exclamation equal. So that means is the value of the variable I not equal to the value of the variable j? True if yes, false if no. So those are comparison operators on integer floats and strings.
On Booleans, you can do some logic operators. And the simplest is just inverting. So if a is a variable that has a Boolean value, not a is just going to invert it. So if a is true, then not a is false, and vice versa. This is a table that sort of represents what I've said here.
So you can use and and or. These are keywords in Python. You can use those 2 keywords on Boolean variables. And you get the result A and B is only true if both A and B are true. And A or B is only false if A and B are false.
And this is the complete table, just in case you need to reference it. So now that we have ways to do logical test. Yeah, question right there. So what does it mean to compare a string with a string with a greater than? Yeah, great question.
So what does it mean to compare a string with a string with a greater than? So that's just going to compare them lexicographically. So does it come first in the alphabet? So we can even test that out. We can say is A greater than B and it's false.
So B comes later in the alphabet than A. OK. So now we have ways to do the tests. So we can add some branching to our programming toolbox now that we have ways to do tests. This is a map of MIT.
I'm going to go through a little example to motivate why we would want to do branching in our code. And I think after this lecture, you'll be able to sort of code up this algorithm that I'm going to explain. So most of us see MIT as a maze. I first did when I came here. When I first came here, obviously, I signed up for the free food mailing list.
And MIT being a maze, I had no idea where to go, right? What the shortest path was to free food. So 1 way to think about it is all I wanted to do is get to the free food. A very simple algorithm to get there would be to say, OK, I'm going to take my right hand, and I'm going to make sure that my right hand is always on a wall. And I'm going to go around campus with my right hand always being at a wall.
And eventually, I'll get to where the free food is. There might not be any left, but I'll be there. So the algorithm is as follows. If my right hand always has to be on a wall, then I'm going to say, if there's no wall to my right side, then I'm going to go right until I get to a wall. Then if there's a wall to my right and I can go forward, I'm just going to keep going forward.
OK. If I keep going forward and there's a wall to my right and in front of me, I'm going to turn around and go left. OK. And then if there's a wall to my right in front of me and to the left, then I'm going to turn around and go back. So with this fairly simple algorithm, I just follow the path, always keeping the wall to my right.
And eventually, I end up where I need to be. So notice I used just in plain English a few keywords, if, otherwise, things like that. So in programming, we have those same constructs. And those same sort of intuitive words can be used to tell Python to do something, or to do something else, or to choose from a different set of possibilities. And This way, we can get the computer to make decisions for us.
Now, you might be thinking, well, you said that computers can't make decisions on their own. It's not. You as programmers are going to build these decisions into the program. And all the computer is going to do is going to reach the decision point and say, OK, this is a decision point. Should I go left or should I go right?
Or which 1 do I pick? And these sort of decisions are created by you as a programmer. And the computer just has to make the decision and choose a path. OK. So in programming, there's 3 sort of simple ways that you can add control flow to your programs.
And that's making 1 decision and choosing whether to execute something or execute something else. The first is the simple if. And given a program that just linearly has statements that get executed, whenever I reach an if statement, you're going to check the condition. The condition is going to be something that's going to get evaluated to either true or false. So I've reached the condition here.
And if the condition's true, then I'm going to additionally execute this extra set of expressions. But if the condition's false, then I'm just going to keep going through the program and not execute that extra set of instructions. How does Python know which instructions to execute? They're going to be inside this what we call code block. And the code block's denoted by indentation.
So it's going to be everything that's indented is part of that if code block. Typically, 4 space is indentation. OK, So that's how you'd write code that decides whether to execute this extra thing or not. Now let's say I don't just want to execute an extra thing. I want to reach a condition.
I want to reach a point where I say, I'll either go down this path or I'll do something else. That's this right here. So this if else construct says, this is my code. I've reached my decision point here. If the condition inside this if is true, then I'm going to execute maybe this set of statements here.
But if the condition is not true, then I'm not going to execute that set of statements. And instead, I'm going to execute under whatever else is. So using this construct, I'm either going to do 1 set of expressions or the other, but never both. Okay? And after I've executed 1 or the other, I'm going to continue on with just the regular execution of the program.
All right. Okay. So we're able to either choose 1 thing, choose 1 thing or another, but what if we want to have more than 1 choice? So if some number is equal to 0, I want to do this. If it's equal to 1, I want to do this.
If it's equal to 2, I want to do this, and so on. That's where this last 1 comes in. And we introduce this other keyword here called lif. So that stands for short form for else if. So, first we check if this condition is true.
So, we're going through our program. We've reached our decision point. If the condition's true, we're going to execute maybe this set of instructions. If the condition's not true, maybe we'll check. If the condition's not true, we will check this next condition.
That's part of the l if right here. And if that one's true, we're going to execute a different set of instructions. You can have more than 1 L if. And depending on which one's true, you're going to execute a different set of instructions. And then this last else is sort of a catch all where if none of the previous conditions were true, then just do this last set of expressions.
So in this case you're going to choose between 1 of these 3, 1 of these 4 roots or however many you have, and then when you're done making your choice you're going to execute the remaining set of instructions. So the way this works is if more than 1 condition is true, you're actually just going to enter 1 of them. And you're going to enter the very first 1 that's true. So you're never going to enter more than 1 of these code blocks. You always enter 1, and you enter the first 1 that evaluates to true.
So notice that we denoted code blocks using indentation. And that's actually 1 of the things that I really like about Python. It sort of forces you to write pretty code and nice looking code and just code that's very readable. And that enforces you to indent everything that's a code block. So you can easily see where the flow of control is and where decision-making points are and things like that.
So in this particular example, we have 1 if statement here. And it checks if 2 variables are equal. And we have an if, elif, else. And in this example, we're going to enter either this code block or this 1 or this 1, depending on the variables of x and y. And we're only going to enter 1 code block.
And we'll enter the first 1. That's true. Notice you can have nested conditionals. So inside this first if, we have another if here. And this inner if is only going to be checked when we enter the first, this outer if.
OK? I do want to make 1 point, though. So sometimes you might forget to do the double equal sign when you're checking for equality, and that's OK. If you just use 1 equal sign, Python's going to give you an error. And it's going to say syntax error.
And it's going to highlight this line. And then you're going to know that there's a mistake there. You should be using equality, Because it doesn't make sense to be using to assign, to be making an assignment inside the if. OK. All right.
So we've learned about branching, and we know about conditionals. Let's try to apply this to a little game. And spoiler, we won't be able to. We'll have to learn about a new thing. But back in 1980s, there was the Legend of Zelda cool graphics where there was a scene with the lost woods.
Oversimplification, if anyone's a Zelda die-hard fan. But the basic idea was, if you entered the woods, You entered from the left to the right. And then as long as you kept going right, it would show you the same screen over and over again. And the trick was you just had to go backward, and then you'd exit the woods. So very simple.
Using what we know so far, we could sort of code this up. And we'd say something like this. If the user exits right, then set the background to the woods background. Otherwise, set the background to the exit background. Now let's say the user and then any else were done.
Let's say the user went right. Well, you'd show them the woods background and now ask them again, where do they want to go? If they exit right, set the background to the woods background. Otherwise, set the background to the exit background. And so on.
So you notice that there's sort of no end to this, right? How many times do you know how many times the user might keep going right? They might be really persistent, right? And they'll be like, maybe if I go 1, 000 times, I'll get out of the woods. Or maybe 1, 001?
Maybe. So this would probably be who knows how deep, these nested ifs. So we don't know. So with what we know so far, we can't really code this cute little game. But enter loops, and specifically a while loop.
So this code here that could be infinitely number of nested if statements deep can be rewritten using these 3 lines. So we say while the user exits right, set the background to the wood's background. And with a while loop, it's going to do what we tell it to do inside the loop, and then it's going to check the condition again. And then it's going to do what we say it should do inside the code block, and then it's going to check the condition again. And then it's going to do what we say it should do inside the code block, and then it's going to check the condition again.
And then as long as the condition is true, it's going to keep doing that little loop there. And as soon as the condition becomes false, it's going to stop doing the loop and do whatever is right after the while. So that's basically how a while loop works. We have while. That's the key word.
The condition is something that gets evaluated to true or false. And once again, we have a code block that's indented. And it tells Python, these are the expressions I want to do as long as the condition is true. So the condition is true. You evaluate every expression in the code block.
When you reach the end of the code block, you check the condition again. If it's true still, you keep doing the expressions, check it again, and so on. So, here's a little game. And with these lines of code, we were able, you know, we can code up the lost woods of Zelda. Even worse graphics, by the way, than the original Zelda is this 1 that I coded up here.
So I print out the following things. You're in the Lost Forest, go left or right. And my program is going to say, you're in the Lost Forest, go left or right. It's going to get user input. It's going to say, while the user keeps typing in right, show them this text, and ask them again.
So I'm asking them again by just saying input here again. And that's it. That's going to just keep getting input from the user. And if the user doesn't type in right and maybe types in left, you're going to exit out of this loop and print out you got out of the loss force. So I have to show you this because I spent too much time on it.
But I decided to improve on the code that's in the slides. And I've written here ways that you guys can also improve it. So if I run my code, you're in the lost forest. Go left or right. So if I say left, then yay, I got out of the lost forest.
But if I go right, then I'm stuck. I took down some trees. You can see there's no more trees here. I made a table, and then I flipped it over. So the expansion to this, if you want to try it out, I put this in the comments here, is try to use a counter.
If the user types in right the first 2 times, just make that a sad face. But if the user types in more than 2 times, make them cut down some trees and build a table and flip it. That's a cute little expansion if you want to test yourself to make sure you're getting loops. So far, we've used while loops to ask for user input. And that's actually somewhere where it makes sense to use while loops, because you don't actually know how many times the user is going to type in something.
You can use while loops to keep sort of a counter and to write code that counts something. If you do that, though, there's 2 things you need to take care of. The first is this first line here, which is sort of an initialization of this loop counter. And the second is this line here, which is incrementing your loop counter. The reason why the second one's important is because, let's look at our condition here.
So while n is less than 5, if you didn't have this line here, you would never increment n. So every time through the loop, you'd just keep printing zeros. And you'd have an infinite loop. I do want to show though what, if you do have an infinite loop, it's not the end of the world. So I can say something like, so while true, print 0.
So this is going to give me an infinite loop in my program. And whoop. Okay. So notice it's just printing the letter P over and over again. And if I let it go any longer, it's going to slow down the computer.
So I'm going to hit Control-C, or Command-C maybe, and it's going to stop the program from printing. So just in case you ever enter infinite loops in your programs, just go to the console and hit Control C, and that's going to stop it from sort of slowing down the computer. OK, so going back to this example, I was saying that if you're using counter variables in order to sort of count up inside the while loop, you have to take care to initialize a counter variable first, and then to incremented. Otherwise, you'll enter an infinite loop. That feels a little bit tedious.
And so there's a shortcut for doing that exact same thing. So these 4 lines, you can rewrite those into these 2 lines right here, using this new type of loop called a for loop. So the for loop says for some loop variable, in this case I named it n. You can name it whatever you want. In range 5, we're going to come back to what range means in a little bit.
Print n. So every time through the loop, you're going to print out what the value of n is. Range 5 actually creates internally a sequence of numbers starting from 0 and going to that number 5 minus 1. So the sequence is going to be 0, 1, 2, 3, and 4. The first time through the loop, you're going to say n is equal to 0.
Or internally, this is what happens. N gets the value 0. You're going to print n. Then you're going to go back to the top, n gets the value 1. Then you're going to go execute whatever's inside.
So you're going to print 1. Then you're going to increment that to the next value in the sequence. You're going to print out 2, and so on. So this is the general look of a for loop. So we have for some loop variable.
Again, can be named whatever you want. In range some number. Do a bunch of stuff. And again, these are part of this for loop code block, so you should indent them to tell Python that these are the things that you should do. So when you're using range some number, you start out with variable getting the value 0.
With variable having value 0, you're going to execute all of these expressions. After all the expressions in the code block are done, you're going to go on to the next value, so 1. You're going to execute all these expressions with variable being value 1, and then so on and so on until you go to some num minus 1. So using range in that way is a little bit constraining Because you're always going to get values starting from 0 and ending at some num minus 1, whatever is in the parentheses and range. Sometimes you might want to write programs that maybe start at a custom value.
Don't start at 0. Maybe they start at 5. Maybe they start at minus 10. And sometimes you might want to write programs that don't increment the numbers by 1, but maybe skip every other number, or go every 2 numbers, every 3 numbers, and so on. So you can customize range to your needs.
The 1 thing you do need to give it is the stop. So if you give it only 1 value in the parentheses, that stands for stop. And by default, start is going to have the value 0 and step is going to have the value 1. If you give it 2 things in the parentheses, you're giving it start and stop. So the first being start, the second being stop, and step gets this value of 1 by default.
And if you give it 3 things in the parentheses, you're giving it start, stop, and step in that order. And you're always going to start at the start value, and stop at, or so you're going to start at the start value, And you're going to go until stop minus 1. So those are the sequences of numbers. So in this first code right here, my sum is going to get the value 0. And you're going to have a for loop.
We're going to start from 7, right? Because we're giving it 2 numbers. And when you give it 2 numbers, it represents start and stop, with step being 1. So you're starting at 7. If step is 1, the next value is 8.
What's the value after that? If we're incrementing by 1, 9. And since we're going until stop minus 1, we're not actually going to pick up on 10. So this loop variable I, the very first time through the loop is going to have the value 7. So my sum is going to be 0 plus 7.
That's everything that's inside the code block. The next time through the loop, I gets the value 8. So inside the for loop, my sum gets whatever the previous value was, which was 7 plus 8. The next time through the loop, my sum gets the value 7 plus 8 plus 9, obviously replacing that with the previous value, so 15. Since we're not going through 10, that's where we stop.
And we're going to print out my sum, which is going to be the value of 7 plus 8 plus 9. Oh, yeah. Oh, OK. Yeah. Do they have to be integers?
That's a great question. We can try that out. I'm not actually sure right off the top of my head. So you can go in Spider and say, Let's say in this example here. So we can say 7.1, 10.3.
Yeah. So they have to be integers. Okay. So that's that example. And let's erase that.
In this particular example, we have start, stop, and step. And here we're going every other value. So we're starting at 5. Tell me what the next value is supposed to be, if we're taking every other 1. 7 and then 9.
And then are we doing 11 or not? Excellent. Nice. Yeah. So we're going to the end minus 1.
OK. So it's possible that sometimes you write code where you might want to exit out of the loop early. You don't want to go through all of the sequences of your numbers. Maybe there's a condition inside there where you just want to exit the loop early. Inside the while loop, maybe you want to exit the loop before the condition becomes false.
So that's where the break statement comes in. So the break works like this. It's going to, as soon as Python sees this break statement, it's going to say, OK, I'm going to look at whatever loop I'm currently in. I'm not evaluating any expression after it that comes within my loop. And I'm going to immediately exit the loop.
So I'm going inside this while, this while. I'm evaluating this 1 expression, and then I suddenly see a break. Expression b does not get evaluated. And break is going to immediately exit out of the innermost loop that it's in. So this y loop that has condition 2, That's the innermost loop that the break is found in.
So we're going to exit out of this innermost loop here and we're evaluating expression C. And notice we're evaluating expression C because it's expression c is part of the outer while loop. It's at the same level as this 1. And these ones are part of the inner while loop. Last thing I want to say is just a little bit of a comparison between for and while loops.
So when would you use 1 or the other? This might be useful in your problem sets. So for loops, you usually use when you know the number of iterations. While loops are very useful when, for example, you're getting user input, and user input is unpredictable. You don't know how many times they're going to do a certain task.
For both for and while loops, you can end out of the loop early using the break. The for loop uses this counter. It's inherent inside the for loop. A while loop, you can use a counter in order, you can use a while loop to count things, but you must initialize the counter before the while loop. And you have to remember to increment it within the loop.
Otherwise you'll, you may be lead to an infinite loop. We've seen in, as the very first example of a for loop that the for loop could be rewritten as a while loop, but the vice versa is not necessarily true. And the counter example to that is just user input. So you might not know how many times you
