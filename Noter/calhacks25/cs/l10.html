<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Understanding Program Efficiency - 6.0001 Lecture 10</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --accent: #f093fb;
            --bg-dark: #0f172a;
            --bg-card: #1e293b;
            --bg-code: #1a1f36;
            --text-primary: #f8fafc;
            --text-secondary: #cbd5e1;
            --text-muted: #94a3b8;
            --border: #334155;
            --success: #10b981;
            --warning: #f59e0b;
            --info: #3b82f6;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: var(--text-primary);
            line-height: 1.7;
            min-height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 280px 1fr;
            max-width: 1600px;
            margin: 0 auto;
            gap: 2rem;
        }

        /* Header */
        header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 3rem 2rem;
            text-align: center;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.05'%3E%3Cpath d='M36 34v-4h-2v4h-4v2h4v4h2v-4h4v-2h-4zm0-30V0h-2v4h-4v2h4v4h2V6h4V4h-4zM6 34v-4H4v4H0v2h4v4h2v-4h4v-2H6zM6 4V0H4v4H0v2h4v4h2V6h4V4H6z'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
            opacity: 0.1;
        }

        header h1 {
            font-size: 2.75rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            position: relative;
            text-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        .course-meta {
            display: flex;
            justify-content: center;
            gap: 2rem;
            margin-top: 1.5rem;
            flex-wrap: wrap;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(255,255,255,0.1);
            padding: 0.5rem 1rem;
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }

        /* Sidebar Navigation */
        aside {
            position: sticky;
            top: 2rem;
            height: fit-content;
            background: var(--bg-card);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid var(--border);
        }

        .nav-title {
            font-size: 0.875rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        .toc {
            list-style: none;
        }

        .toc li {
            margin-bottom: 0.5rem;
        }

        .toc a {
            color: var(--text-secondary);
            text-decoration: none;
            display: block;
            padding: 0.5rem 0.75rem;
            border-radius: 8px;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .toc a:hover {
            background: rgba(102, 126, 234, 0.1);
            color: var(--primary);
            transform: translateX(4px);
        }

        .toc a.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            color: white;
            font-weight: 600;
        }

        /* Main Content */
        main {
            background: var(--bg-card);
            border-radius: 16px;
            padding: 3rem;
            margin-bottom: 2rem;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            border: 1px solid var(--border);
        }

        section {
            margin-bottom: 4rem;
            scroll-margin-top: 2rem;
        }

        h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            padding-bottom: 0.75rem;
            border-bottom: 3px solid var(--primary);
            display: inline-block;
        }

        h3 {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 2rem 0 1rem;
            color: var(--accent);
        }

        p {
            margin-bottom: 1.25rem;
            color: var(--text-secondary);
            font-size: 1.05rem;
        }

        /* Callout Boxes */
        .callout {
            padding: 1.5rem;
            border-radius: 12px;
            margin: 2rem 0;
            border-left: 4px solid;
            background: rgba(255,255,255,0.03);
            backdrop-filter: blur(10px);
        }

        .callout-info {
            border-color: var(--info);
            background: rgba(59, 130, 246, 0.1);
        }

        .callout-warning {
            border-color: var(--warning);
            background: rgba(245, 158, 11, 0.1);
        }

        .callout-success {
            border-color: var(--success);
            background: rgba(16, 185, 129, 0.1);
        }

        .callout-title {
            font-weight: 700;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Code Blocks */
        .code-container {
            position: relative;
            margin: 2rem 0;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 8px 30px rgba(0,0,0,0.4);
        }

        .code-header {
            background: linear-gradient(135deg, #2d3748, #1a202c);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .code-language {
            font-family: 'Fira Code', monospace;
            font-size: 0.875rem;
            color: var(--accent);
            font-weight: 600;
        }

        .copy-button {
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 0.375rem 0.875rem;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .copy-button:hover {
            background: var(--primary);
            color: white;
        }

        pre {
            background: var(--bg-code);
            padding: 1.5rem;
            overflow-x: auto;
            margin: 0;
            font-family: 'Fira Code', monospace;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        code {
            font-family: 'Fira Code', monospace;
            color: #e2e8f0;
        }

        .keyword { color: #c792ea; }
        .function { color: #82aaff; }
        .string { color: #c3e88d; }
        .comment { color: #546e7a; font-style: italic; }
        .number { color: #f78c6c; }

        /* Lists */
        ul, ol {
            margin: 1.5rem 0;
            padding-left: 2rem;
        }

        li {
            margin-bottom: 0.75rem;
            color: var(--text-secondary);
        }

        /* Complexity Table */
        .complexity-table {
            width: 100%;
            border-collapse: collapse;
            margin: 2rem 0;
            background: var(--bg-dark);
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }

        .complexity-table th {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }

        .complexity-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .complexity-table tr:last-child td {
            border-bottom: none;
        }

        .complexity-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.875rem;
            font-weight: 600;
            font-family: 'Fira Code', monospace;
        }

        .badge-constant { background: rgba(16, 185, 129, 0.2); color: var(--success); }
        .badge-log { background: rgba(59, 130, 246, 0.2); color: var(--info); }
        .badge-linear { background: rgba(245, 158, 11, 0.2); color: var(--warning); }
        .badge-quadratic { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

        /* Key Takeaways */
        .key-takeaways {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 2rem;
            margin: 3rem 0;
        }

        .key-takeaways h3 {
            color: var(--primary);
            margin-top: 0;
        }

        /* Smooth Scroll */
        html {
            scroll-behavior: smooth;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .container {
                grid-template-columns: 1fr;
            }

            aside {
                position: relative;
                top: 0;
            }

            main {
                padding: 2rem;
            }
        }

        /* Animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        section {
            animation: fadeIn 0.6s ease-out;
        }

        /* Formula Display */
        .formula {
            background: var(--bg-dark);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            text-align: center;
            margin: 1.5rem 0;
            border: 1px solid var(--border);
            font-size: 1.1rem;
        }

        .highlight {
            color: var(--accent);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Understanding Program Efficiency</h1>
            <div class="course-meta">
                <div class="meta-item">
                    <span>üìö</span>
                    <span>6.0001 - Introduction to Computer Science</span>
                </div>
                <div class="meta-item">
                    <span>üìñ</span>
                    <span>Lecture 10</span>
                </div>
                <div class="meta-item">
                    <span>üéì</span>
                    <span>MIT OpenCourseWare</span>
                </div>
            </div>
        </header>

        <aside>
            <div class="nav-title">Table of Contents</div>
            <ul class="toc">
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#why-efficiency">Why Efficiency Matters</a></li>
                <li><a href="#measuring">Measuring Efficiency</a></li>
                <li><a href="#timing">Timing Programs</a></li>
                <li><a href="#counting">Counting Operations</a></li>
                <li><a href="#big-o">Big O Notation</a></li>
                <li><a href="#complexity-classes">Complexity Classes</a></li>
                <li><a href="#linear">Linear Complexity</a></li>
                <li><a href="#quadratic">Quadratic Complexity</a></li>
                <li><a href="#code-examples">Code Examples</a></li>
                <li><a href="#takeaways">Key Takeaways</a></li>
            </ul>
        </aside>

        <main>
            <section id="introduction">
                <h2>Introduction: Setting the Stage</h2>
                <p>
                    As we approach the end of the first section of this course, let's reflect on what you've learned. You've mastered the fundamentals of computation, explored various data structures (tuples, lists, dictionaries), and encountered different algorithmic approaches‚Äîfrom simple linear code to recursive algorithms, divide and conquer strategies, and object-oriented programming with classes.
                </p>
                <p>
                    Now it's time to ask a crucial question: <strong>How efficient are our algorithms?</strong>
                </p>
                <div class="callout callout-info">
                    <div class="callout-title">üéØ Learning Objectives</div>
                    <ul>
                        <li>Understand how to reason about algorithm efficiency</li>
                        <li>Learn to predict runtime for different problem sizes</li>
                        <li>Recognize how design choices influence performance</li>
                        <li>Master Big O notation and complexity classes</li>
                    </ul>
                </div>
            </section>

            <section id="why-efficiency">
                <h2>Why Should We Care About Efficiency?</h2>
                <p>
                    You might think: "Computers are getting faster every year‚Äîdoes efficiency really matter?" The answer is an emphatic <strong>yes</strong>, and here's why:
                </p>

                <div class="callout callout-warning">
                    <div class="callout-title">‚ö†Ô∏è The Scale Problem</div>
                    <p>
                        In 2014, Google served <strong>30 trillion pages</strong> covering <strong>100 million gigabytes</strong> of data. Could a simple sequential search algorithm find information in any reasonable time? Absolutely not.
                    </p>
                </div>

                <h3>Real-World Applications</h3>
                <ul>
                    <li><strong>Web Search:</strong> Google's MapReduce algorithm (co-written by an MIT grad!) enables efficient searching across massive datasets</li>
                    <li><strong>Genomics:</strong> Analyzing DNA sequences requires processing enormous amounts of biological data</li>
                    <li><strong>Surveillance Systems:</strong> Government agencies tracking patterns across global image databases</li>
                    <li><strong>Social Networks:</strong> Processing billions of user interactions in real-time</li>
                </ul>

                <p>
                    While simple solutions are often easiest to write, sophisticated algorithms become essential when dealing with large-scale problems. The data grows faster than computer speeds improve.
                </p>
            </section>

            <section id="measuring">
                <h2>How Do We Measure Efficiency?</h2>
                <p>
                    We need to separate two important concepts: <strong>time efficiency</strong> and <strong>space efficiency</strong>. While both matter, we'll focus primarily on time‚Äîhow long it takes algorithms to solve problems.
                </p>

                <div class="callout callout-info">
                    <div class="callout-title">‚öñÔ∏è The Time-Space Tradeoff</div>
                    <p>
                        Sometimes we can pre-compute and store results (using more space) to reduce computation time later. Remember the dictionary-based Fibonacci implementation? That's a classic time-space tradeoff‚Äîwe used more memory to dramatically reduce computation time.
                    </p>
                </div>

                <h3>The Challenge</h3>
                <p>Even for a single algorithm, we face several complications:</p>
                <ul>
                    <li>An algorithm can be implemented in many different ways</li>
                    <li>A problem can be solved using different algorithms</li>
                    <li>We need to separate implementation details from algorithmic choices</li>
                </ul>

                <h3>Three Approaches to Measurement</h3>
                <ol>
                    <li><strong>Timing:</strong> Run the code and measure actual execution time</li>
                    <li><strong>Counting Operations:</strong> Count fundamental operations as a function of input size</li>
                    <li><strong>Order of Growth:</strong> Abstract notion of how runtime scales (our focus)</li>
                </ol>
            </section>

            <section id="timing">
                <h2>Approach 1: Timing Programs</h2>
                <p>
                    Python provides a timer module that lets us measure execution time:
                </p>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">import</span> time

<span class="keyword">def</span> <span class="function">c_to_f</span>(c):
    <span class="keyword">return</span> c * <span class="number">9.0</span> / <span class="number">5</span> + <span class="number">32</span>

<span class="comment"># Start timing</span>
t0 = time.clock()
<span class="function">c_to_f</span>(<span class="number">100000</span>)
t1 = time.clock() - t0

<span class="function">print</span>(<span class="string">"Time elapsed:"</span>, t1, <span class="string">"seconds"</span>)</code></pre>
                </div>

                <h3>Problems with Timing</h3>
                <div class="callout callout-warning">
                    <div class="callout-title">‚ùå Why Timing Isn't Ideal</div>
                    <ul>
                        <li><strong>Implementation dependent:</strong> Small code changes affect timing</li>
                        <li><strong>Machine dependent:</strong> Different computers yield different results</li>
                        <li><strong>Not predictive:</strong> Small input timing doesn't predict large input behavior</li>
                        <li><strong>Conflates factors:</strong> Mixes algorithm efficiency with implementation details</li>
                    </ul>
                </div>
            </section>

            <section id="counting">
                <h2>Approach 2: Counting Operations</h2>
                <p>
                    A better approach: count the number of fundamental operations as a function of input size.
                </p>

                <h3>Primitive Operations</h3>
                <p>We assume these operations take constant time:</p>
                <ul>
                    <li>Arithmetic operations (addition, multiplication, division)</li>
                    <li>Comparisons (==, >, <)</li>
                    <li>Assignments (setting a variable)</li>
                    <li>Memory retrieval (accessing a value)</li>
                </ul>

                <h3>Example: Simple Function</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">c_to_f</span>(c):
    <span class="keyword">return</span> c * <span class="number">9.0</span> / <span class="number">5</span> + <span class="number">32</span>  <span class="comment"># 3 operations</span></code></pre>
                </div>

                <h3>Example: Loop Function</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">mysum</span>(x):
    total = <span class="number">0</span>              <span class="comment"># 1 operation</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(x + <span class="number">1</span>):  <span class="comment"># loop x times</span>
        total += i         <span class="comment"># 2 operations (add and assign)</span>
    <span class="keyword">return</span> total         <span class="comment"># 1 operation</span>

<span class="comment"># Total: 1 + 3x + 1 = 3x + 2 operations</span></code></pre>
                </div>

                <div class="formula">
                    Operations = <span class="highlight">1 + 3x + 1 = 3x + 2</span>
                </div>

                <p>
                    This gives us a concrete relationship: if x = 10, we need 32 operations. If x = 100, we need 302 operations. If x = 1,000, we need 3,002 operations.
                </p>

                <h3>Advantages and Limitations</h3>
                <div class="callout callout-success">
                    <div class="callout-title">‚úÖ Better than Timing</div>
                    <ul>
                        <li>Depends on the algorithm (what we want to measure)</li>
                        <li>Independent of which computer we use</li>
                        <li>Gives us a mathematical relationship</li>
                    </ul>
                </div>

                <div class="callout callout-warning">
                    <div class="callout-title">‚ö†Ô∏è Still Not Perfect</div>
                    <p>
                        Still depends somewhat on implementation. A <code>for</code> loop vs. <code>while</code> loop might count differently (3x vs. 4x operations), but we don't really care about that distinction.
                    </p>
                </div>
            </section>

            <section id="big-o">
                <h2>Approach 3: Order of Growth (Big O Notation)</h2>
                <p>
                    This is the approach computer scientists use. We focus on how the algorithm scales when the input size gets arbitrarily large, ignoring small implementation details.
                </p>

                <h3>Key Principles</h3>
                <ul>
                    <li><strong>Focus on large inputs:</strong> What happens when n gets really big?</li>
                    <li><strong>Ignore constants:</strong> 3x + 2 and 4x + 1 both grow linearly</li>
                    <li><strong>Dominant terms matter:</strong> In n¬≤ + 2n + 2, only n¬≤ matters for large n</li>
                    <li><strong>Upper bound:</strong> We want to know the worst-case behavior</li>
                </ul>

                <div class="callout callout-info">
                    <div class="callout-title">üìê Simplification Rules</div>
                    <p><strong>Drop constants and focus on dominant terms:</strong></p>
                    <ul>
                        <li>n¬≤ + 2n + 2 ‚Üí <span class="highlight">O(n¬≤)</span></li>
                        <li>n¬≤ + 100,000n + 31,000 ‚Üí <span class="highlight">O(n¬≤)</span></li>
                        <li>log(n) + n + 4 ‚Üí <span class="highlight">O(n)</span></li>
                        <li>0.0001 √ó n √ó log(n) + 300n ‚Üí <span class="highlight">O(n log n)</span></li>
                        <li>2n¬≥‚Å∞ + 3‚Åø ‚Üí <span class="highlight">O(3‚Åø)</span></li>
                    </ul>
                </div>

                <h3>Why This Works</h3>
                <p>
                    Consider n¬≤ + 2n + 2. When n = 10, the total is 122. When n = 100, it's 10,202. When n = 1,000, it's 1,002,002. Notice how the n¬≤ term dominates as n grows? That's why we only care about it.
                </p>

                <div class="formula">
                    If we <span class="highlight">double n</span>, does the time double? Quadruple? Stay the same?
                </div>
            </section>

            <section id="complexity-classes">
                <h2>Complexity Classes</h2>
                <p>
                    Algorithms fall into different complexity classes based on their growth rates:
                </p>

                <table class="complexity-table">
                    <thead>
                        <tr>
                            <th>Notation</th>
                            <th>Name</th>
                            <th>Example</th>
                            <th>Growth Pattern</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><span class="complexity-badge badge-constant">O(1)</span></td>
                            <td>Constant</td>
                            <td>Array access, simple math</td>
                            <td>No change with input size</td>
                        </tr>
                        <tr>
                            <td><span class="complexity-badge badge-log">O(log n)</span></td>
                            <td>Logarithmic</td>
                            <td>Binary search</td>
                            <td>Doubles when input increases 10√ó</td>
                        </tr>
                        <tr>
                            <td><span class="complexity-badge badge-linear">O(n)</span></td>
                            <td>Linear</td>
                            <td>Simple loops, linear search</td>
                            <td>Doubles when input doubles</td>
                        </tr>
                        <tr>
                            <td><span class="complexity-badge badge-linear">O(n log n)</span></td>
                            <td>Log-linear</td>
                            <td>Efficient sorting (merge sort)</td>
                            <td>Slightly worse than linear</td>
                        </tr>
                        <tr>
                            <td><span class="complexity-badge badge-quadratic">O(n¬≤)</span></td>
                            <td>Quadratic</td>
                            <td>Nested loops</td>
                            <td>Quadruples when input doubles</td>
                        </tr>
                        <tr>
                            <td><span class="complexity-badge badge-quadratic">O(c‚Åø)</span></td>
                            <td>Exponential</td>
                            <td>Recursive Fibonacci</td>
                            <td>Explodes rapidly</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Growth Comparison</h3>
                <p>Let's see how these classes compare for different input sizes:</p>

                <table class="complexity-table">
                    <thead>
                        <tr>
                            <th>Class</th>
                            <th>n=10</th>
                            <th>n=100</th>
                            <th>n=1,000</th>
                            <th>n=1,000,000</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>O(1)</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>O(log n)</td>
                            <td>1</td>
                            <td>2</td>
                            <td>3</td>
                            <td>6</td>
                        </tr>
                        <tr>
                            <td>O(n)</td>
                            <td>10</td>
                            <td>100</td>
                            <td>1,000</td>
                            <td>1,000,000</td>
                        </tr>
                        <tr>
                            <td>O(n log n)</td>
                            <td>10</td>
                            <td>200</td>
                            <td>3,000</td>
                            <td>6,000,000</td>
                        </tr>
                        <tr>
                            <td>O(n¬≤)</td>
                            <td>100</td>
                            <td>10,000</td>
                            <td>1,000,000</td>
                            <td>1,000,000,000,000</td>
                        </tr>
                        <tr>
                            <td>O(2‚Åø)</td>
                            <td>1,024</td>
                            <td>1.27√ó10¬≥‚Å∞</td>
                            <td colspan="2" style="text-align: center;">Good luck! üöÄ</td>
                        </tr>
                    </tbody>
                </table>

                <div class="callout callout-warning">
                    <div class="callout-title">‚ö†Ô∏è Exponential Growth is Devastating</div>
                    <p>
                        Notice how exponential algorithms become completely impractical even for modest input sizes. This is why algorithm choice matters so much!
                    </p>
                </div>
            </section>

            <section id="linear">
                <h2>Linear Complexity: O(n)</h2>
                <p>
                    Simple iterative loops typically have linear complexity. The time grows proportionally with the input size.
                </p>

                <h3>Example 1: Linear Search (Unsorted List)</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">linear_search</span>(L, e):
    found = <span class="keyword">False</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(L)):
        <span class="keyword">if</span> e == L[i]:
            found = <span class="keyword">True</span>
    <span class="keyword">return</span> found</code></pre>
                </div>

                <p><strong>Analysis:</strong></p>
                <ul>
                    <li>Loop runs <code>len(L)</code> times</li>
                    <li>Each iteration: constant operations (comparison, assignment)</li>
                    <li>Worst case: element not in list, must check all elements</li>
                    <li><strong>Complexity:</strong> <span class="complexity-badge badge-linear">O(n)</span> where n = len(L)</li>
                </ul>

                <div class="callout callout-info">
                    <div class="callout-title">‚ö° Constant Time List Access</div>
                    <p>
                        Why is <code>L[i]</code> constant time? Python stores lists in contiguous memory. For a list of integers, each element takes 4 bytes. To access the i-th element: <code>base_address + 4√ói</code>. Direct calculation, no iteration needed!
                    </p>
                </div>

                <h3>Example 2: Linear Search (Sorted List)</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">search</span>(L, e):
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(L)):
        <span class="keyword">if</span> L[i] == e:
            <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">if</span> L[i] > e:  <span class="comment"># Can stop early if list is sorted!</span>
            <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">return</span> <span class="keyword">False</span></code></pre>
                </div>

                <p><strong>Analysis:</strong></p>
                <ul>
                    <li>Average case: faster than unsorted search</li>
                    <li>Worst case: still O(n) (element not in list)</li>
                    <li>Order of growth unchanged, but practical runtime improved</li>
                </ul>

                <h3>Example 3: Factorial (Iterative)</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">fact_iter</span>(n):
    <span class="string">"""assumes n an int >= 0"""</span>
    answer = <span class="number">1</span>
    <span class="keyword">while</span> n > <span class="number">1</span>:
        answer *= n
        n -= <span class="number">1</span>
    <span class="keyword">return</span> answer</code></pre>
                </div>

                <p><strong>Analysis:</strong></p>
                <ul>
                    <li>Loop runs n times</li>
                    <li>Each iteration: 5 operations (test, multiply, assign, subtract, assign)</li>
                    <li>Total: 1 + 5n + 1 = 5n + 2 operations</li>
                    <li><strong>Complexity:</strong> <span class="complexity-badge badge-linear">O(n)</span></li>
                </ul>

                <div class="formula">
                    5n + 2 ‚Üí Drop constants ‚Üí <span class="highlight">O(n)</span>
                </div>
            </section>

            <section id="quadratic">
                <h2>Quadratic Complexity: O(n¬≤)</h2>
                <p>
                    Nested loops typically lead to quadratic complexity. When you have a loop inside a loop, the time grows with the square of the input size.
                </p>

                <h3>Example 1: Subset Check</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">isSubset</span>(L1, L2):
    <span class="string">"""Check if every element of L1 appears in L2"""</span>
    <span class="keyword">for</span> e1 <span class="keyword">in</span> L1:
        matched = <span class="keyword">False</span>
        <span class="keyword">for</span> e2 <span class="keyword">in</span> L2:
            <span class="keyword">if</span> e1 == e2:
                matched = <span class="keyword">True</span>
                <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">not</span> matched:
            <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">return</span> <span class="keyword">True</span></code></pre>
                </div>

                <p><strong>Analysis:</strong></p>
                <ul>
                    <li>Outer loop: runs <code>len(L1)</code> times</li>
                    <li>Inner loop: runs up to <code>len(L2)</code> times for each outer iteration</li>
                    <li>Worst case: L1 and L2 same length, no elements match</li>
                    <li><strong>Complexity:</strong> <span class="complexity-badge badge-quadratic">O(len(L1) √ó len(L2))</span></li>
                    <li>If both lists have length n: <span class="complexity-badge badge-quadratic">O(n¬≤)</span></li>
                </ul>

                <div class="callout callout-warning">
                    <div class="callout-title">üìä Law of Multiplication</div>
                    <p>
                        When you have nested loops, multiply their complexities:
                    </p>
                    <div class="formula">
                        O(outer) √ó O(inner) = O(n) √ó O(n) = <span class="highlight">O(n¬≤)</span>
                    </div>
                </div>

                <h3>Example 2: List Intersection</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">intersect</span>(L1, L2):
    <span class="string">"""Return list of elements in both L1 and L2"""</span>
    tmp = []
    <span class="keyword">for</span> e1 <span class="keyword">in</span> L1:
        <span class="keyword">for</span> e2 <span class="keyword">in</span> L2:
            <span class="keyword">if</span> e1 == e2:
                tmp.append(e1)
    
    res = []
    <span class="keyword">for</span> e <span class="keyword">in</span> tmp:
        <span class="keyword">if</span> <span class="keyword">not</span>(e <span class="keyword">in</span> res):  <span class="comment"># This is O(n) operation!</span>
            res.append(e)
    <span class="keyword">return</span> res</code></pre>
                </div>

                <p><strong>Analysis:</strong></p>
                <ul>
                    <li>First nested loop: O(len(L1) √ó len(L2))</li>
                    <li>Second loop: O(len(tmp)) iterations</li>
                    <li>But <code>e in res</code> is itself O(len(res)) ‚âà O(len(L1))</li>
                    <li>Second loop total: O(len(L1)¬≤)</li>
                    <li><strong>Overall:</strong> <span class="complexity-badge badge-quadratic">O(n¬≤)</span> (assuming similar list lengths)</li>
                </ul>

                <div class="callout callout-info">
                    <div class="callout-title">üîç Hidden Complexity</div>
                    <p>
                        Watch out for operations that look simple but hide loops! The <code>in</code> operator for lists performs a linear search, adding hidden complexity to your algorithm.
                    </p>
                </div>

                <h3>Visual Pattern Recognition</h3>
                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python</span>
                        <button class="copy-button">Copy</button>
                    </div>
                    <pre><code><span class="keyword">def</span> <span class="function">g</span>(n):
    <span class="string">"""Computes n¬≤ inefficiently"""</span>
    x = <span class="number">0</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(n):
        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="function">range</span>(n):
            x += <span class="number">1</span>
    <span class="keyword">return</span> x</code></pre>
                </div>

                <p>
                    When you see nested loops with the same range, think <strong>quadratic</strong>. The outer loop runs n times, and for each iteration, the inner loop also runs n times: n √ó n = n¬≤.
                </p>
            </section>

            <section id="code-examples">
                <h2>Complete Code Examples</h2>
                <p>
                    Here are all the code examples from this lecture, ready to run and experiment with:
                </p>

                <div class="code-container">
                    <div class="code-header">
                        <span class="code-language">Python - Complete Examples</span>
                        <button class="copy-button">Copy All</button>
                    </div>
                    <pre><code><span class="comment"># -*- coding: utf-8 -*-</span>
<span class="comment">"""
Created on Sun Oct  9 11:27:54 2016
@author: ericgrimson

Complexity Analysis Examples
"""</span>

<span class="comment"># LINEAR SEARCH - Unsorted List</span>
<span class="keyword">def</span> <span class="function">linear_search</span>(L, e):
    <span class="string">"""
    Search for element e in list L
    Returns True if found, False otherwise
    Complexity: O(n) where n = len(L)
    """</span>
    found = <span class="keyword">False</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(L)):
        <span class="keyword">if</span> e == L[i]:
            found = <span class="keyword">True</span>
    <span class="keyword">return</span> found

<span class="comment"># Test data</span>
testList = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">18</span>, <span class="number">27</span>]


<span class="comment"># LINEAR SEARCH - Sorted List (Optimized)</span>
<span class="keyword">def</span> <span class="function">search</span>(L, e):
    <span class="string">"""
    Search for element e in SORTED list L
    Can stop early if we pass where e should be
    Complexity: Still O(n) worst case, but faster average case
    """</span>
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(L)):
        <span class="keyword">if</span> L[i] == e:
            <span class="keyword">return</span> <span class="keyword">True</span>
        <span class="keyword">if</span> L[i] > e:
            <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">return</span> <span class="keyword">False</span>


<span class="comment"># SUBSET CHECK - Quadratic Complexity</span>
<span class="keyword">def</span> <span class="function">isSubset</span>(L1, L2):
    <span class="string">"""
    Check if L1 is a subset of L2
    (every element of L1 appears in L2)
    Complexity: O(len(L1) * len(L2))
    Worst case: O(n¬≤) if lists are same length
    """</span>
    <span class="keyword">for</span> e1 <span class="keyword">in</span> L1:
        matched = <span class="keyword">False</span>
        <span class="keyword">for</span> e2 <span class="keyword">in</span> L2:
            <span class="keyword">if</span> e1 == e2:
                matched = <span class="keyword">True</span>
                <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">not</span> matched:
            <span class="keyword">return</span> <span class="keyword">False</span>
    <span class="keyword">return</span> <span class="keyword">True</span>


<span class="comment"># Test data for subset</span>
testSet = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]
testSet1 = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>]  <span class="comment"># Is a subset</span>
testSet2 = [<span class="number">1</span>, <span class="number">6</span>]      <span class="comment"># Not a subset (6 not in testSet)</span>


<span class="comment"># INTERSECTION - Quadratic Complexity</span>
<span class="keyword">def</span> <span class="function">intersect</span>(L1, L2):
    <span class="string">"""
    Return list of elements that appear in both L1 and L2
    Each element appears only once in result
    Complexity: O(len(L1) * len(L2)) + O(len(L1)¬≤) = O(n¬≤)
    """</span>
    <span class="comment"># First, find all common elements (may have duplicates)</span>
    tmp = []
    <span class="keyword">for</span> e1 <span class="keyword">in</span> L1:
        <span class="keyword">for</span> e2 <span class="keyword">in</span> L2:
            <span class="keyword">if</span> e1 == e2:
                tmp.append(e1)
    
    <span class="comment"># Remove duplicates</span>
    res = []
    <span class="keyword">for</span> e <span class="keyword">in</span> tmp:
        <span class="keyword">if</span> <span class="keyword">not</span>(e <span class="keyword">in</span> res):  <span class="comment"># Note: 'in' is O(n) operation!</span>
            res.append(e)
    <span class="keyword">return</span> res


<span class="comment"># Example usage and testing</span>
<span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:
    <span class="comment"># Test linear search</span>
    <span class="function">print</span>(<span class="string">"Linear Search Tests:"</span>)
    <span class="function">print</span>(<span class="function">linear_search</span>(testList, <span class="number">5</span>))   <span class="comment"># True</span>
    <span class="function">print</span>(<span class="function">linear_search</span>(testList, <span class="number">10</span>))  <span class="comment"># False</span>
    
    <span class="comment"># Test sorted search</span>
    <span class="function">print</span>(<span class="string">"\nSorted Search Tests:"</span>)
    <span class="function">print</span>(<span class="function">search</span>(testList, <span class="number">5</span>))   <span class="comment"># True</span>
    <span class="function">print</span>(<span class="function">search</span>(testList, <span class="number">10</span>))  <span class="comment"># False</span>
    
    <span class="comment"># Test subset</span>
    <span class="function">print</span>(<span class="string">"\nSubset Tests:"</span>)
    <span class="function">print</span>(<span class="function">isSubset</span>(testSet1, testSet))  <span class="comment"># True</span>
    <span class="function">print</span>(<span class="function">isSubset</span>(testSet2, testSet))  <span class="comment"># False</span>
    
    <span class="comment"># Test intersection</span>
    <span class="function">print</span>(<span class="string">"\nIntersection Tests:"</span>)
    <span class="function">print</span>(<span class="function">intersect</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]))  <span class="comment"># [2, 3]</span>
    <span class="function">print</span>(<span class="function">intersect</span>([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]))        <span class="comment"># []</span></code></pre>
                </div>
            </section>

            <section id="takeaways">
                <div class="key-takeaways">
                    <h3>üéØ Key Takeaways</h3>
                    
                    <h4>1. Why Efficiency Matters</h4>
                    <ul>
                        <li>Data sets grow faster than computer speeds improve</li>
                        <li>Algorithm choice can mean the difference between seconds and years</li>
                        <li>Real-world applications (search engines, genomics, surveillance) demand efficient algorithms</li>
                    </ul>

                    <h4>2. Measuring Efficiency</h4>
                    <ul>
                        <li><strong>Timing:</strong> Machine and implementation dependent (not ideal)</li>
                        <li><strong>Counting operations:</strong> Better, but still implementation dependent</li>
                        <li><strong>Order of growth (Big O):</strong> Best‚Äîfocuses on algorithm, ignores constants</li>
                    </ul>

                    <h4>3. Big O Notation Rules</h4>
                    <ul>
                        <li>Drop additive constants: 3n + 2 ‚Üí O(n)</li>
                        <li>Drop multiplicative constants: 5n ‚Üí O(n)</li>
                        <li>Keep only the dominant term: n¬≤ + n ‚Üí O(n¬≤)</li>
                        <li>Focus on worst-case behavior</li>
                    </ul>

                    <h4>4. Common Complexity Classes (Best to Worst)</h4>
                    <ul>
                        <li><span class="complexity-badge badge-constant">O(1)</span> Constant - Ideal but rare</li>
                        <li><span class="complexity-badge badge-log">O(log n)</span> Logarithmic - Excellent (binary search)</li>
                        <li><span class="complexity-badge badge-linear">O(n)</span> Linear - Good (simple loops)</li>
                        <li><span class="complexity-badge badge-linear">O(n log n)</span> Log-linear - Acceptable (efficient sorting)</li>
                        <li><span class="complexity-badge badge-quadratic">O(n¬≤)</span> Quadratic - Problematic (nested loops)</li>
                        <li><span class="complexity-badge badge-quadratic">O(c‚Åø)</span> Exponential - Avoid if possible!</li>
                    </ul>

                    <h4>5. Pattern Recognition</h4>
                    <ul>
                        <li><strong>Single loop over n items:</strong> O(n)</li>
                        <li><strong>Nested loops over n items:</strong> O(n¬≤)</li>
                        <li><strong>Dividing problem in half repeatedly:</strong> O(log n)</li>
                        <li><strong>Hidden loops:</strong> Watch for operations like <code>in</code> that hide O(n) complexity</li>
                    </ul>

                    <h4>6. Laws of Complexity</h4>
                    <ul>
                        <li><strong>Law of Addition:</strong> Sequential code ‚Üí add complexities ‚Üí keep dominant term</li>
                        <li><strong>Law of Multiplication:</strong> Nested code ‚Üí multiply complexities</li>
                    </ul>

                    <h4>7. Next Steps</h4>
                    <p>
                        In the next lecture, we'll explore more complexity classes and see how clever algorithm design can dramatically improve efficiency. We'll discover that sorted lists enable much faster searching than O(n)!
                    </p>
                </div>
            </section>

            <div style="text-align: center; padding: 2rem; color: var(--text-muted); border-top: 1px solid var(--border); margin-top: 4rem;">
                <p>üìö MIT OpenCourseWare | 6.0001 Introduction to Computer Science and Programming in Python</p>
                <p style="font-size: 0.9rem; margin-top: 0.5rem;">
                    For more information about citing these materials or our Terms of Use, visit: 
                    <a href="https://ocw.mit.edu/terms" style="color: var(--primary);">https://ocw.mit.edu/terms</a>
                </p>
            </div>
        </main>
    </div>

    <script>
        // Smooth scroll and active navigation
        document.addEventListener('DOMContentLoaded', function() {
            const tocLinks = document.querySelectorAll('.toc a');
            const sections = document.querySelectorAll('section');

            // Highlight active section in TOC
            function highlightActiveSection() {
                let current = '';
                sections.forEach(section => {
                    const sectionTop = section.offsetTop;
                    const sectionHeight = section.clientHeight;
                    if (pageYOffset >= sectionTop - 200) {
                        current = section.getAttribute('id');
                    }
                });

                tocLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.getAttribute('href') === '#' + current) {
                        link.classList.add('active');
                    }
                });
            }

            window.addEventListener('scroll', highlightActiveSection);
            highlightActiveSection();

            // Copy button functionality (visual only)
            const copyButtons = document.querySelectorAll('.copy-button');
            copyButtons.forEach(button => {
                button.addEventListener('click', function() {
                    this.textContent = 'Copied!';
                    setTimeout(() => {
                        this.textContent = 'Copy';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>