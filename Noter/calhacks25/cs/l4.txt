The following content is provided under a Creative Commons license. Your support will help MIT OpenCourseWare continue to offer high quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses, visit MIT OpenCourseWare at ocw.mit.edu. All right, everyone, let's get started. All right, good afternoon on this rainy, sad afternoon.
So I'm glad we're inside, though. OK, so lecture 4 of 6.001 and 600. Quick, quick recap of what we did last time. So last time, we did a little bit more string manipulations. And then we saw how you can use for loops over strings directly.
So instead of having for loops that iterate over range, so 0, 1, 2, 3, 4, and so on, you saw that it was more powerful to sometimes use for loops that iterate over string objects directly. So that was the first half of the lecture. In the second half, we started looking at different ways that you can implement different implementations to the same problem. So we saw the problem of finding the cube root. And we saw some implementations.
We saw the guess and check method and the approximation method. And then we looked at what I thought was the most powerful method, which was the bisection method. And this 1, if you remember, I played a game with someone in the audience where I guessed a number between 0 and 100. And we saw that I was able to guess that number really, really quickly using the bisection method. And that's the method that you're going to implement, that you are currently implementing in your problem set.
OK, so today, So that sort of finishes introduction to some of the more basic mechanisms in Python. And today we're going to talk about how to structure your programs such that you write nice coherent code, reusable code, by hiding away some of the details in your code. And to do that, we're going to look at these things called functions. All right, so just stepping back and sort of getting a high level view of how we write the code so far. So so far, The way that you've been writing code for your programs is you open a file, you type some code to solve a particular problem given, like in your problem sets.
Each file contains some piece of code. You have sequences of instructions that contain maybe assignments, loops, conditionals, and so on and so on. But really, you have 1 file that contains each code, and you write everything in that particular file. But this is OK for smaller problems that we've been seeing so far. But when you're starting to write large pieces of code, it's going to get really messy really quickly.
So think about if you want to use a for loop in 1 part of your code, and you find it useful to use that same for loop in another part of your code. Some point in the future, as you're debugging your code, you might want to change your original for loop. You have to figure out all the other places where you've used that type of for loop, for example. So as you're scaling your code, you'll find it harder to keep track of these details. So this is where functions will come into play in today's lecture.
We'll help you with it. If you want to be considered a good programmer and good programming style, it would be to not necessarily add lots and lots of lines of code, but really to add more functionality to your programs. So how many different things, how many different features can your program do, rather than how long can your code be? And that'll help you later on look at your code if you need it for a future class. And it'll help others if they want to look at your code later on if they find it useful.
So today we're introducing this idea of functions. And functions are mechanisms to achieve decomposition and abstraction. So these are 2 key words here that are going to pop up in today's lecture and also in future lectures. So before I introduce decomposition and abstraction in the context of functions, Let's first take a look at just sort of a real life example. So let's take a projector.
I'm using 1 right now. Quick show of hands. If I give you all of the electronic components that are part of a projector, right? Resistors, a fan, a light bulb, a lens, the casing, all of the different parts in it. Who here would be able to build a projector?
Do I see a hand? No? Oh, yeah, nice. You can also lie. I won't know the difference.
But if you can do that I'd be very impressed. All right, so you can't really put together a projector, right? Another show of hands. If I gave you a projector that's fully assembled, okay, and I gave you a computer, for example, who would be able to maybe figure out within, let's say, an hour how to make them work together? Good.
Fair bit of the class. That's perfect. That's exactly the answers I was trying to get at here. So none of us really know how a projector works, the internals, but a lot more of us know how to work a projector, just given maybe a set of basic instructions or just intuitively speaking. So you see the projector as sort of a black box.
You don't need to know how it works in order to use it. You know maybe what inputs it might take, what's it supposed to do at a high level. Take whatever's on my screen and put it up on the large screen there. Just magnify it. But you don't know how it does it, how the components work together.
So that's the idea of abstraction. You don't need to know how the projector works in order to use it. OK, that's abstraction. The other half of that was decomposition. So let's say that now, given a projector, I want to project a very, very large image down on a very large stage.
For example, this is from 1 of the Olympics. It's a stage of 10 football fields, something like that. Something massive. You could build 1 projector that's able to project a very large image, but that would be really expensive. And you'd have to build this 1 projector that's used for this 1 time.
So instead, what you could do is you could take a bunch of smaller projectors and feed different inputs to each 1 of them. And as you're feeding different inputs, each one's going to show a different output. And then you're going to be able to have all of these different projectors working together to solve this larger problem of projecting this really cool image on a very large stage. So that's the idea of decomposition. You take the same projector, feed it different inputs.
It does the exact same thing behind the scenes, but it'll produce a different output for each 1 of these different inputs. So these different devices are going to work together to achieve the same common goal. That's the idea of decomposition. So these were applied to the problem of projecting large image or a projector in general. But we can apply these exact same concepts to programming.
So decomposition is really just the problem of creating structure in your code. In the projector example, we have separate devices working together. In programming, To achieve decomposition, you're dividing your code into smaller modules. These are going to be self-contained. And you can think of them as sort of little mini programs.
You feed in some input to them. They do a little task. And then they give you something back. They go off and do their thing. And then they give back a result.
These modules can be used to break up your code. And the important thing is that they're reusable. So you write a module once, a little piece of code that does something once. You debug it once. And then you can reuse it many, many times in your code with different inputs.
The benefit of this is it keeps your code organized and it keeps your code coherent. So Functions are going to be used to achieve decomposition and to create structure in our code. We're going to see functions today in this lecture. And in a few weeks, you're going to actually see when we talk about object-oriented programming how you can achieve decomposition with classes. And With classes, you can create your own object types, like ints and floats.
You can create your own object types for whatever you want. But that's later. OK. So decomposition is creating structure in your code. And abstraction is the idea of suppressing details.
So in the projector example, remember abstraction was you didn't need to know exactly how the projector worked in order to use it, and it's going to be the same idea in programming. So once you write a piece of code that does a little task, you don't need to rewrite that piece of code many times. You've written it once. And you write this thing called a function specification for it, or a doc string. And this is a piece of text that tells anyone else who'd want to use it in the future, other people, maybe yourself, it tells them, how do you use this function?
What inputs does it take? What's the type of the inputs? What is the function supposed to do? And what is the output that you're going to get out of it? So they don't need to know exactly how you implemented the function.
They just need to know inputs, what it does, what's the output, those 3 things. OK. So these functions are then reusable chunks of code. And we'll see in a few examples today's lecture how to write some and how to call functions. And as we're going through today's code, I want you to think about functions with 2 different hats on.
The first hat is from someone who's writing the function. So in the projector example, someone had to build the first projector. Someone had to know how to put all these components together. So that's going to be you writing a function. So you need to know how to make the function work.
And then the other hat is you as a programmer who's just using the function. You're assuming it's already been implemented correctly. And now you're just using it to do something. So these are some of the function characteristics. And we'll see an example on the next slide.
So a function is going to have a name. You have to call it something. It's going to have some parameters. These are the inputs to the function. You can have 0 inputs or as many as you'd like.
Function should have a doc string. This is how you achieve abstraction. So it's optional but highly recommended. And this is how you tell other people how to use your function. Function has a body, which is the meat and potatoes of the function, what it does.
And a function is going to return something. It computes its thing, and then it spits back some answer. Here's an example of a function definition and a function call. Function definition is up here. I'll just draw it here.
This is the function definition up here. And this is the function call down here. So remember, someone has to write the function that does something to begin with. So this is how you write the function. The first is going to be this DEF keyword.
And DEF stands for, it tells Python I'm going to define a function. Next is the name of the function. In this case, I'm calling the function is underscore even. And the function name should really be something descriptive, whereas someone who's just using this function or looking at it can pretty much tell what it's supposed to do without going a lot farther than that, than just looking at the name. And then in parentheses, you give it any parameters, also known as arguments.
These parameters are the inputs to the function. And then you do colon. So this is the first line of the function definition. And after this, everything that's going to be part of the function is going to be indented. The next part is going to be the docstring or the specification.
And this is how we achieve abstraction using functions. Specification or the doc string starts with triple quotes and ends with triple quotes. And you can sort of think about this as a multi-line comment. It's just going to be text that's going to be visible to whoever uses the function. And it should tell them the following things.
What are the inputs to the function? What is the function supposed to do, generally? And what is the function going to give back to whoever called it? The next part is going to be the body of the function. We'll talk about what's inside it in the next slide.
And that's it. That's all for the function definition. Def blah, blah, blah, indented everything inside the function. So this is you writing the function definition. Once the function definition is written, you can call the function.
And that's this part down here. And here, when you call a function, you just say its name, and then you give it parameters. And you give it as many parameters as the function is expecting, in this case only 1 parameter. So what's inside the function body? You can put anything inside the function body.
You remember, think of a function as sort of a small procedure, a little mini program that does something. So you can do anything inside the function that you can do in a regular program, print things, do mathematical operations, and so on. The last line is the most important part of the function, though. And it's this return statement. That's what we call it.
So it's a line of code that starts with return, which is a key word. And then it's going to be some value. Notice this is an expression here. I% 2 is equal equals 0 is an expression that's going to evaluate to some value. And as long as this part is something that evaluates some value, it could be anything you want.
And this line here, return something, tells Python, OK, after you finished executing everything inside the function, what value should I return? And whoever called the function is going to get back that value. And the function call itself will be replaced by that value. OK. So let's look at an example.
I'm going to introduce the idea of scope now. And scope just means, is another word for environment. So if I told you that you can think of functions as little mini programs, the scope of a function is going to be a completely separate environment than the environment of the main program. So as soon as you make a function call, behind the scenes what Python says is, OK, I'm in the main program, but I see a function call. I'm going to step out of this main program.
I'm going to go off into this new environment. I'm going to create an entirely new set of variables that just exist within this environment. I'm going to do some computations. When I see the return, I'm going to take this 1 return value. I'm going to exit that environment.
And then I'm going to come back to the main program. So as you're entering from 1 scope to another, you're sort of passing these values back and forth. So when you're entering a scope, you're passing a variable into the function. And when the function is finished, you're passing a value back to whoever called it. So once again, this top part is the function definition.
And any arguments for the function definition are called formal parameters. And they're called formal parameters because, notice, they don't actually have a value yet. In the function definition, you're sort of writing the function assuming that, in this case, x is going to have some value. But you don't know what it is yet. You only know what value x takes when you make a function call down here.
So this is your function definition, and then later on in your main program, you might define some variable x is equal to 3, And then you make a function call. F of x here is your function call. And it says, OK, I'm calling f with the value 3, because x takes the value 3. And then I'm going to map 3 into the function. The values that are passed into the function call are called actual parameters, because they're going to actually have a value.
So let's step through this program, this little small program, and see what exactly happens behind the scenes in the scope. And if you're just starting the program, I think it would be highly valuable if you take a piece of paper as you're doing some of these exercises and you write down something similar to what I'm going to go through here. I think it'll help a lot. And you'll be able to see exactly, step by step, what variables take what values and which scope you're in. So here we go.
When the program first starts, we're creating this global scope. It's the main program scope. In the main program scope, the first thing that Python is going to see is this part here, def f of x, and then some stuff inside. This tells Python, I have a function named x, but I don't care what's inside the code yet. I don't care what's inside the function definition yet, because I haven't called the function yet.
So, to Python, it's just some code just sitting in the global scope. So whenever you see DEF, you're just putting some code in there. Then you go on to the next line. X is equal to 3. So in the global scope, you now have also variable x is 3.
And then the next line, z is equal to f of x, is a function call. As soon as you hit a function call, you create a new scope, a new environment. So we're temporarily leaving the global scope and sort of portaling into a new scope, where we're going to try to figure out what this function is going to do and what it's going to return. So the first thing you do is you map the parameters. So x here, I'm calling f of x with 3.
So the first thing I'm doing is I'm mapping every 1 of the parameters in the definition to their values. So the first thing I'm doing is x gets the value 3. Next line here is x is equal to x plus 1. So we're still inside the function call f. So x gets the value 4.
We're printing this, and then we're returning x. So in the scope of f, x is equal to 4. So we're returning that value back to whoever called it, which was this function call within the global scope. So this part right here, f of x, which was the function call, gets replaced with 4. So inside the main program, z is equal to 4.
And that's how we pass parameters into the function, and we got a parameter back from the function. As soon as the function returns something, the scope that you were in for the function gets erased. You forget about every variable that was created in there. Delete that scope, and you're back to wherever you started calling it. 1 warning, though.
So what happens if there's no return statement? I said that every function has to return something. If you don't explicitly put a return statement, Python is going to add 1 for you. You don't have to do this. And it's going to actually have return none, n-o-n-e.
And none is the special type. None is the value for a special type called non-type. And it represents the absence of a value. What's that? Not a string.
None is not a string. None is not a string, exactly. It's a special type. OK, so before we go on, I wanted to go through a small exercise in Spyder just to show you the difference that none and printing and returning makes. So here are 2 functions that I wrote.
1 is even with return. That's its name, so pretty descriptive. It's pretty much the same code we saw in the slides. It just has this extra little print thing. It gets the remainder when I is divided by 2.
And it returns whether the remainder is equal to 0. So it will either return a true or a false Boolean. So my function call is this. I'm saying is even with return with a value 3. When I make this function call, this 3 gets mapped into here, this variable here.
So I is equal to 3. I'm going to print with return, and then I'm going to say remainder is equal to 3% 2, which comes out to value 1, because there's remainder 1. And I'm going to return whether 1 is equal to 0, which is false. So this line here returns false. But am I doing anything with the false?
Not really. It's just sort of sitting in the code here. So this gets evaluated to false. I'm not printing it. I'm not doing any operations with it.
It's just sitting there. So it won't show up anywhere. If I want the result to show up somewhere, then I have to print it. So that's what this next line is doing. So that 1 should be straightforward.
Is even without returns a little bit trickier, but not too bad. I have print without return inside here. And then I'm going to get a remainder is equal to I% 2. And notice that I don't have any return. So implicitly, Python is going to add a return none for me, like that.
You don't have to add it. So when I make the function call here, it's going to do the same thing, except the return in this case is not going to be a Boolean. It's going to be this special none. So this is going to get evaluated to none. Again, I'm not printing it out.
It's just sitting there. If I were to print out the result of that, you'd be printing out this value none, which if I run it, you'll see here it just prints it out right there. So as you're doing your next pset, it's about functions, and you're seeing these none's popping out in some places. Check to make sure that you've actually returned something as opposed to just printed something inside the function, like we did here. All right, So that's the difference.
And the last thing I want to mention about this is even function is how useful it can be. So this is the function as in the slides. And once you write the function once, You can use it many, many times in your code. So here I have I'm using the function is even to print the numbers between 0 and 19, including and whether the number is even or odd. So notice this piece of code here.
Once I've written this function is even, it looks really, really nice. I have 4 of the numbers in this range. If the number I is even, this is going to return a true or false for all the numbers 0, 1, 2, 3, 4. If it's true, then I'm going to print out even, and otherwise I'm going to print out odd. So if I run this, it's going to do this.
0, even, 1, odd, 2, even, and so on. So notice, using functions makes my code really nice looking. If I wasn't using functions, I'd have to put these 2 lines somewhere inside here. And it would look a little bit messier. So I've said this maybe once or twice before.
In Python, everything is an object. Might not have meant anything back then, but I think You're going to see what I mean using this particular example. So if in Python everything's an object, integers are objects, floats are objects, even functions are objects. So as you can pass objects as parameters back and forth as function parameters. You can also pass other functions as parameters.
Let's see what this means. So we have 3 function definitions here, func a, func b, and func c. And then I have 3 lines of code here in my main program. So I have 1 call to func a, 1 call to func b, and 1 call to func c. Let's trace through, just like in the previous example, and see what exactly happens.
First thing I create is my global scope, and I have 3 function definitions. Again, I don't care what's in the code yet because I haven't called the functions yet. Python just knows there's these functions with these names that contain some code. After these definitions, I come to this line here, print func a. As soon as I make a function call, I'm going to create a new scope and I'm going to hop into there.
Inside func a, I'm going to go And look at what func a does. It doesn't take any parameters. It just prints out this message here. And then it leaves. It's done.
There's no return. So we return none. So func a returns none to whoever called it, which was that line there. So that is going to be none. Next line, this 1 right here, print 5 plus some function call.
Again, I'm going to hop into FunkB's scope and see what to do there. So first, I'm going to map my parameters. So 2 gets mapped to y. So inside FunkB's scope, y is going to get the value 2. That's the very first thing I'm doing, mapping all the parameters.
Then I'm going to print this thing here, and then I'm going to return y. So inside funcb, y has the value 2, and I'm returning 2 back to whoever called me. So this is the value 2. And I'm going to print 5 plus 2, which is 7. Last 1.
This is the trickiest. That popped up. If you think you've got it, try that exercise. But otherwise, follow along. Print func c func a.
So I see that I am going to enter func c's scope. So I'm going to look at what funcc does. First thing I do is I'm mapping all the parameters. Don't even worry about the fact that this is a function right now. Just pretend it's x or something.
So you say func a is going to get mapped to the variable z inside func c. So z is func c, just mapping parameters from actual to formal. Then what do we do inside func c? We print out inside func c. And then we return z.
This is the cool part. Inside func c, z is func a. So if you replace z with func a, this here becomes return func a open close parentheses. Look familiar? We did that function call right there, right?
So that's just another function call. So with that being another function call, you're going to create another scope, and you're going to pop into that 1. So we're 12I guess 2 scopes deep. We're trying to figure out where we're going. So func A's scope is going to be up here.
So what does func A do? It just prints out this, and it returns none. So we're going to return none to whoever called us, which was func C. So this line here becomes return None. And so this line here is going to return None to whoever called it, which was this line down here.
Oops, I didn't mean to cross it out. So that line here is going to print none. So if you just go step by step, it shouldn't be too bad to try to map what happens with variable names and for all parameters and actual parameters. That's why I highly recommend pieces of paper and pens. 1 last thing I want to mention about scope before we do another example.
So there are 3 sort of situations you might find yourself in. The first 1 is probably the most typical. And this is when you define a function, and it's using a variable named x in this case that's also defined outside of the function. And that doesn't matter because of the idea of scopes. So inside the global scope, you can have variables x.
When you're inside a different scope, you can have whatever variable names you want. And when you're inside that scope, Python's going to use those variable names. So they don't interfere with each other at all. So in this example, I've defined a variable x is equal to 1, and then I increment it. And that doesn't interfere with the fact that we have a variable x outside.
This one's a little bit trickier. I define this function g. And all g does is access a variable x. But notice inside g, I've never actually declared or initialized a variable x, right? In this f, I said x is equal to 1.
But in here, I'm just sort of using x. So this does not give you an error. In fact, it's OK for you to do this in Python. Python says, OK, I'm in this scope, but I don't have a variable named x. So let me just go into the scope of whoever called me.
So I'm going to just temporarily hop out of the scope and see, is there a variable x outside of me? And it'll find this variable x here, and it's going to print out its values. So that's OK. This last example here is actually not allowed in Python, similar to this 1, except that I'm trying to increment a value of x, but then I'm also trying to reassign it to the same value of x. The problem with that is I never actually initialized x inside h.
So if inside h I said x is equal to 1, and then I did x plus equals to 1, then it would be this example here, f of y. But I didn't do that. I just tried to access x and then increment it, and then try to reassign it. And that's actually not allowed in Python. There is a way around it using global variables.
But it's actually frowned upon to use global variables. The global variables are part of the readings for this lecture. And the reason why it's not a great idea to use global variables is because global variables sort of give you this loophole around scopes. So it allows you to write code that can become very messy. So using global variables, you can be inside a function and then modify a variable that's defined outside of your function.
And that sort of defeats the purpose of functions and using them and writing these coherent modules that are separate. That said, it will sometimes be useful to use global variables, as you'll see in a couple lectures from now. OK. Cool. So let's go on to the last scope example.
OK, this slide is here. And notice I've bolded, underlined, and italicized the Python tutor, because I find it extremely helpful. So the Python tutor, as I've mentioned in 1 of the assignments, it was actually developed by a grad student here or grad student slash postdoc here. And it allows you to go through Python, paste the code, go through it step by step. Like with each iteration, it will show you exactly what values each variable has, what scope you're in, when scopes get created, when scopes get destroyed, variables within each scope.
So pretty much every single detail you need to sort of understand functions. You can see we've had a couple questions, and these are great questions. So if you're still trying to understand what's going on, I would highly suggest you take a piece of code and just run it into the Python Tutor, and you should be able to see exactly what happens in sort of a similar way that I've drawn my diagrams. In all of the codes for this particular lecture, I've put links to the Python Tutor for each 1 of those exercises. You can just copy and paste those, and it'll automatically populate it with that particular example.
So you just have to click step, step, step. So having made my plug for Python Tutor, let's go on. So here's an example. It's going to show a couple things. 1 is what happened, you know, print versus return.
And also this idea of you can nest functions. So just so you could have nested loops, nested conditionals, you can also nest functions within functions. So let's draw some diagrams, just like before, of the scopes. First thing we're going to do is, when we have a program, we're going to create the global scope, and we're going to add every variable that we have. And then when we reach a function call, we're going to do something about that.
So the first thing in the global scope is this function definition. Again, in my global scope, I just have g as some code because I have not called it yet. I only go inside a function when I make a function call. So g contains some code. So we're done with 75% of that code.
Next line is x is equal to 3. So I'm making x be a variable inside my global scope with value 3. And then I have this z is equal to g of x. This is a function call. When I see a function call, I'm going to create a new scope.
So here is the scope of G. With the scope of G, I'm mapping variables to actual parameters to formal parameters. So the first thing I'm doing is I'm saying inside g, what is the value of actual parameter x? And x is going to be the value 3, because I've called g of x with x is equal to 3. Next, what I see inside this function, so this is the inside of the function, is this bit here.
It's another function definition. Again, since I'm just defining the function and I'm not calling it, All Python sees is H is some code. I haven't called the function H yet, because I'm just defining it here with def. So that finishes this part here. The next line is x is equal to x plus 1.
So inside the scope of g, I'm incrementing x to be 4. Then I'm printing out this line. And then I've reached here, h. This is actually a function call, and I'm calling h. As soon as I make a function call, I'm creating another scope.
So I'm temporarily going out of the scope of g and going into the scope of h. So Python knows that H contains some code, and now I can go inside H and do whatever I need to do. So H doesn't have any parameters, so I don't need to populate anything like that in there. H does define a variable called x, which is ABC. It's a string.
And then that's all h does. What does it return? None. I heard murmuring, but I think none was what you guys are saying. So since there's no return statement, H is going to return none.
So H returns none back to whoever called it, which was this code inside G. So that gets replaced with none, the thing that I've this circled red h here. As soon as h returns, we're going to get rid of that scope, all the variables created within it, and we're done with h. So now we're back into g. And we just finished executing this, and this got replaced with none.
We're not printing it out, so this doesn't show up anywhere. It's just there. So we're finished with that line, and the next line is return x. So x inside g is 4. So 4 gets returned back to whoever called it, which was in the global scope here.
So this gets replaced with 4. So once we've returned x, we've completely exited out of the scope of g. And we've come back to whoever called us, which was global scope. And we've replaced z is equal to g of x. And that completely got replaced with 4, the return value.
So that's showing nested functions. Just circling back to decomposition abstraction, this is the last slide. You can see, if you look at the code associated with today's lecture, There's some other examples where you can see just how powerful it is to use functions. And you can write really clean and simple code if you define your own functions and then just use them later. And the beauty of defining your own functions that you can use multiple times later is you only have to debug the function once, right?
I know debugging is not your favorite thing, but you only have to debug this 1 thing once. And then you can know that it's right and it works well. And you can just use it multiple times. All right. Thanks, everyone.
Thank you.